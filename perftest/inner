#!/usr/bin/python3

# Copyright (c) 2020 Interri Kft.
# This file is an unpublished work. All rights reserved.

# Usage: inner [-d|--debugging] [-f|--firebuild=/path/to/tree] test
#
# This script runs the given test (specified in the command line) from tests.conf.
#
# The test is run on the current host.
#
# The "-f DIR" (defaults to ~/firebuild) parameter needs to point to the topmost
# directory of the checked out firebuild git tree, with the binary already built
# under its "build" subdirectory.
#
# The build dependencies also need to be already installed.
#
# The sources for the test will be downloaded by this program.
#
# This script is meant to be run inside an LXC container, launched by "outer",
# although you can run manually as well on your host (without doing any LXC stuff).
#
# This script must be started from its containing directory.
#
# The result (timing data) is appended to ~/buildtimes.csv, unless "-d" was
# specified.

import argparse
import csv
import glob
import itertools
import os
import re
import resource
import shutil
import sys
import time


parser = argparse.ArgumentParser()
parser.add_argument("-d", "--debugging",
                    action="store_true",
                    help="debugging firebuild (skip non-firebuild build, don't record performance)")
parser.add_argument("-j","--jobs",
                    default=str(os.cpu_count()),
                    help="list of parallelism levels to use in builds, default is 1,4. Passing empty string will use \"-j\"")
parser.add_argument("--with-diffoscope",
                    action="store_true",
                    help="compare build results with diffoscope (needs diffoscope and fakeroot pre-installed)")
parser.add_argument("-r","--generate-report",
                    action="store_true",
                    help="Generate a report for each firebuild-intercepted run and save them")
parser.add_argument("--tests-conf",
                    default="tests.conf",
                    help="configuration file with test descriptions")
parser.add_argument("test",
                    help="name of the test to run, or <name>:<type>:<timeout minutes>",
                    metavar="TEST")
args = parser.parse_args()


def debug(str):
  print(" ðŸ”¸ " + str, file=sys.stderr, flush=True)


# Convert exit status from Unix/Python-style (high byte: exit code, low byte: signum)
# to shell-style (128 + signum if there was a signal).
def shell_exit_status(status):
  if os.WIFEXITED(status):
    return os.WEXITSTATUS(status)
  elif os.WIFSIGNALED(status):
    return os.WTERMSIG(status)
  else:
    return 127


builddir = os.path.expanduser("~/perftest-build")
# debugging slows down firebuild, especially if "firebuild -d proc" is set
timeout_multiplier = 2 if args.debugging else 1


def run_build_cmd(cmd, timeout_minutes=0):
  start_monotonic = time.monotonic()
  start_res = resource.getrusage(resource.RUSAGE_CHILDREN)

  if timeout_minutes > 0:
    cmd = "timeout -s ABRT " + str(timeout_minutes) + "m " + cmd

  debug("Running Â«" + cmd + "Â»")
  status = os.system(cmd)
  status = shell_exit_status(status)

  end_monotonic = time.monotonic()
  end_res = resource.getrusage(resource.RUSAGE_CHILDREN)

  real = end_monotonic - start_monotonic
  user = end_res.ru_utime - start_res.ru_utime
  sys = end_res.ru_stime - start_res.ru_stime

  maybe_load = ""
  if status == 124:
    # The "timeout" command reported a timeout. Log the load average of the last 1 minute,
    # to give a hint whether it was more likely an actual timeout (while the build command
    # was still running, i.e. high load), or more likely an earlier deadlock (low load).
    maybe_load = ", load_avg_1m=" + str(os.getloadavg()[0])

  debug("Command completed, status={}, real={:.3f}, user={:.3f}, sys={:.3f}{}"
        .format(status, real, user, sys, maybe_load))

  return (status, {
    "real": real,
    "user": user,
    "sys": sys
  })


def restore_saved_tree(name, dir):
  debug("Restoring the source tree of Â«" + name + "Â»")
  if os.access(dir, os.F_OK):
    shutil.rmtree(dir)
  shutil.copytree(dir + ".saved", dir,
                  symlinks=True, ignore_dangling_symlinks=True)


# Get disk usage, in kilobytes, or 0 if the directory doesn't exist
def get_du(dir):
  ret = os.popen("du -s " + dir + " 2>/dev/null | cut -f1").read().strip()
  return int(ret or "0")


def build_debs(srcdir):
  timeout_minutes = 5
  source_epoch = os.popen("dpkg-parsechangelog -SDate -l " + srcdir + "/debian/changelog | date -f- +%s").read().strip()
  cmd = "fakeroot env DEB_BUILD_OPTIONS='nocheck' SOURCE_DATE_EPOCH='{}' debian/rules binary".format(source_epoch)
  run_build_cmd("env -C " + srcdir + " " + cmd, timeout_minutes)
  os.system("env -C " + srcdir + " dpkg-genchanges -O../pkg.changes")


def save_debs(srcdir, phase):
  debs_dir = "{}/../debs-{}".format(srcdir, phase)
  os.makedirs(debs_dir, exist_ok=True)
  # Move .deb, .ddeb and .changes files to debs_dir
  for f in glob.glob("{}/../*.deb".format(srcdir)):
    os.system("mv {} {}".format(f, debs_dir))


def debs_differ(dir1, dir2):
  debs = set()
  with os.scandir(dir1) as it:
    for entry in it:
        if entry.name.endswith('.deb') and entry.is_file():
            debs.add(entry.name)
  diffoscope_failed = False
  for deb in debs:
    diffoscope_ret = os.system("diffoscope --no-progress --text-color never {}/{} {}/{}".format(dir1, deb, dir2, deb))
    if diffoscope_ret != 0:
      diffoscope_failed = True
  return diffoscope_failed


def build_project(name, params):
  # Automatically generate "dl", "dir" and "cmd" if "type" is "deb"
  if params.get("type") == "deb":
    dl = "apt-get source " + name
    # FIXME is this "sort --version-sort | tail -1" robust enough to get the latest version, if there was a package update?
    version = os.popen("apt-cache showsrc " + name + " | grep ^Version: | cut -d' ' -f2 | cut -d- -f1 | cut -d: -f2 | sort --version-sort | tail -1").read().strip()
    dir = name + "-" + version
    cmds = "env DEB_BUILD_OPTIONS='nocheck parallel={NR}' MAKEFLAGS=-j{NR} debian/rules build"

  # Look at manual "dl", "dir" and "cmd", may override the autogenerated one
  if "dl" in params:
    dl = params["dl"]
  if "dir" in params:
    prep = params["dir"]
  if "cmd" in params:
    cmds = params["cmd"]

  # cmds can be a single command as a scalar for convenience, or an array. Turn into an array.
  if type(cmds) == str:
    cmds = [cmds]

  # Simple handling of repetition count, without requiring another level of nesting in the big loop.
  if params.get("repeat"):
    cmds *= params["repeat"]

  dldir = builddir + "/" + name  # e.g. /home/ubuntu/perftest-build/mc
  srcdir = dldir + "/" + dir     # e.g. /home/ubuntu/perftest-build/mc/mc-4.8.24
  fbcachedir = dldir + "/" + ".fbcache"
  os.environ["FIREBUILD_CACHE_DIR"] = fbcachedir
  timeout_minutes = params["timeout_minutes"]

  # Clean up previous stuff, in case of non-LXC build
  shutil.rmtree(dldir, ignore_errors=True)

  debug("Downloading Â«" + name + "Â»")
  os.makedirs(dldir, exist_ok=True)
  ret = os.system("cd " + dldir + " && " + dl)
  if ret:
    debug("Download error")
    shutil.rmtree(dldir, ignore_errors=True)
    return shell_exit_status(ret)
  if "prep" in params:
    debug("Preparing the source of Â«" + name + "Â»")
    ret = os.system("cd " + srcdir + " && " + params["prep"])
    if ret:
      debug("Preparation error")
      shutil.rmtree(srcdir, ignore_errors=True)
      return shell_exit_status(ret)
  debug("Saving the source tree of Â«" + name + "Â»")
  if os.access(srcdir + ".saved", os.F_OK):
    shutil.rmtree(srcdir + ".saved")
  os.rename(srcdir, srcdir + ".saved")

  parallel_levels = args.jobs.split(",")
  for (cmd_pattern, jobs) in itertools.product(cmds, parallel_levels):
    cmd = re.sub("{NR}", str(jobs), cmd_pattern)
    start_timestamp = int(time.time())

    status = 0
    # Fake times for steps that weren't executed
    times0 = { "real": 0, "user": 0, "sys": 0 }
    times1 = { "real": 0, "user": 0, "sys": 0 }
    times2 = { "real": 0, "user": 0, "sys": 0 }

    # Phase 0: Build without firebuild
    if not args.debugging:
      restore_saved_tree(name, srcdir)
      debug("Building Â«" + name + "Â» without firebuild")
      (status, times0) = run_build_cmd("env -C " + srcdir + " " + cmd, timeout_minutes)
      # Firebuild-intercepted builds must finish well within twice the time of vanilla builds,
      # but add extra 2 minutes just in case for very short builds
      timeout_minutes = 2 + int(2 * times0["real"] / 60)
      if status == 0 and args.with_diffoscope:
        build_debs(srcdir)
        save_debs(srcdir, 0)

    # Phase 1: If the previous phase was okay, build with firebuild for the first time
    if status == 0:
      debug("Removing Â«" + fbcachedir + "Â»")
      shutil.rmtree(fbcachedir, ignore_errors=True)

      restore_saved_tree(name, srcdir)
      debug("Building Â«" + name + "Â» with firebuild, empty cache")
      os.system("touch /tmp/firebuild_started")
      os.system("firebuild --version")
      firebuild_params = "-r/tmp/report-1.html" if args.generate_report else ""
      (status, times1) = run_build_cmd("env -C {} firebuild {} -- {}".format(srcdir, firebuild_params, cmd), timeout_minutes * timeout_multiplier)
      if status == 0 and args.with_diffoscope:
        build_debs(srcdir)
        save_debs(srcdir, 1)

    # Record cache size
    cachesize1 = get_du(fbcachedir)

    # Phase 2: If the previous phase was okay, build with firebuild for the second time
    if status == 0:
      restore_saved_tree(name, srcdir)
      debug("Building Â«" + name + "Â» with firebuild, from cache")
      firebuild_params = "-r/tmp/report-2.html" if args.generate_report else ""
      (status, times2) = run_build_cmd("env -C {} firebuild {} -- {}".format(srcdir, firebuild_params, cmd), timeout_minutes)
      if status == 0 and args.with_diffoscope:
        build_debs(srcdir)
        save_debs(srcdir, 2)

    # Record cache size
    cachesize2 = get_du(fbcachedir)

    end_timestamp = int(time.time())

    diffoscope_failed = False
    if status:
      core_dumps = glob.glob("/var/tmp/core.*")
      if core_dumps:
        os.system("sudo apt-get install -qqy gdb")
      for core_dump in core_dumps:
        if re.match("/var/tmp/core\.firebuild", core_dump):
          binary = "/usr/bin/firebuild"
        else:
          binary = "/usr/lib/*/libfirebuild.so.?"
        os.system("gdb -batch -ex \"bt full\" " + binary + " " + core_dump)
    else:
      if args.with_diffoscope:
        if not args.debugging:
          diffoscope_failed = debs_differ(srcdir + "/../debs-0", srcdir + "/../debs-1")
        diffoscope_failed = diffoscope_failed or debs_differ(srcdir + "/../debs-1", srcdir + "/../debs-2")

    # Write a CSV row
    if not args.debugging:
      firebuild_version = os.popen("firebuild --version | awk '/Firebuild Git / {print $3}'").read().strip()
      firebuild_timestamp =  os.popen("date -d \"$(dpkg-parsechangelog -l /usr/share/doc/firebuild/changelog.gz -S Date)\" +%s").read().strip()
      with open(os.path.expanduser("~/buildtimes.csv"), "a") as csvfile:
        writer = csv.writer(csvfile, lineterminator='\n')
        writer.writerow([start_timestamp, end_timestamp,
                         firebuild_version, firebuild_timestamp,
                         name, cmd, status,
                         "{:.3f}".format(times0["real"]), "{:.3f}".format(times0["user"]), "{:.3f}".format(times0["sys"]),
                         "{:.3f}".format(times1["real"]), "{:.3f}".format(times1["user"]), "{:.3f}".format(times1["sys"]),
                         "{:.3f}".format(times2["real"]), "{:.3f}".format(times2["user"]), "{:.3f}".format(times2["sys"]),
                         cachesize1, cachesize2, jobs])

    if status:
      return status

  return 0 if not diffoscope_failed else 1


# Enable core dumps
(soft, hard) = resource.getrlimit(resource.RLIMIT_CORE)
resource.setrlimit(resource.RLIMIT_CORE, (hard, hard))

# Run the test
try:
  (test, test_type, timeout) = args.test.split(":")
  params = {'type' : test_type, 'timeout_minutes' : int(timeout)}
except ValueError:
  # Read the test definitions
  with open(args.tests_conf, "r") as f:
    tests = eval(f.read())
  test = args.test
  params = tests[test]

ret = build_project(test, params)
sys.exit(ret)
